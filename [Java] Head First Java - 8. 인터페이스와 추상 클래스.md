# Head First Java

## 8. 인터페이스와 추상 클래스

- 인터페이스 : 100% 추상 클래스

- Tiger 객체나 Lion 객체가 아닌 Animal은 객체가 아님

  - 어떤 클래스의 인스턴스를 만들 수 없게 하는 방법(new 키워드 쓸 수 없게 하는 방법) : 클래스를 abstract로 지정하면 됨

- 클래스의 상속 구조를 설계할 때는 클래스를 추상 클래스로 만들지 아니면 구상 클래스(concrete class)로 만들지를 결정해야 함

  - 구상 클래스 : 인스턴스를 만들어도 될 만큼 구체적인 클래스

  ```java
  abstract class Canine extends Animal {
      public void roam() {}
  }
  ```

- 컴파일러에서 추상 클래스의 인스턴스를 만드는 것을 허용하지 않음

- 추상 클래스 

  - 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스
  - 확장하지 않으면 가치 없음
  - 추상 클래스를 만들었을 때 실제 실행 중에 일을 처리하는 것은 그 추상 클래스의 하위 클래스 인스턴스임

- 추상 메소드

  - 반드시 오버라이드해야하는 메소드이므로 추상 메소드는 모두 구현해야 함

  - 추상 메소드에는 몸통이 없음

    ```java
    public abstract void eat(); // 메소드 본체 없고 세미콜론으로 끝
    ```

  - 추상 메소드를 만들 때는 클래스도 반드시 추상 클래스여야 함

  - 추상 클래스 안에는 추상 메소드와 추상 메소드 아닌 메소드 모두 가능

  - 추상 메소드를 만드는 이유는 일련의 하위클래스를 위한 규약(protocol)의 일부를 정의하기 위함

  - 장점 : 다형성

- Object 클래스

  - 자바에서 모든 클래스는 Object 클래스를 확장한 것임

  - 명시적으로 다른 클래스를 확장하지 않은 클래스는 자동으로 Object를 확장한 클래스로 정의됨

  - Object는 추상 클래스가 아님

    - 이유 : 모든 클래스에서 무조건 오버라이드할 필요 없이 그대로 사용할 수 있는 메소드를 구현해놓은 코드가 있기 때문임
    - Object의 메소드 중 일부는 오버라이드 가능하고 일부는 불가능 함

  - 용도

    - 임의 클래스에 대해 어떤 작업을 하는 메소드를 만들 때 다형적 유형으로 사용하는 경우
    - 자바에 있는 모든 객체에서 실행 중에 필요한 진짜 메소드 코드를 제공하기 위함

  - 다형적 유형을 사용하는 것이 좋은데 왜 모든 메소드의 인자와 리턴 유형을 Object로 하지 않는 것인가?

    - 모든 타입을 Object로 한다는 것은 자바에서 코드를 보호하는 가장 중요한 메커니즘 가운데 하나인 '유형 안정성(type-safety)'이 완전히 무의미해진다는 것임

    - 어떤 객체를 Object 레퍼런스 유형을 써서 참조하면 자바에서는 항상 그 레퍼런스가 Object 유형의 인스턴스를 참조하고 있다고 생각하기 때문에 그 객체에 대해서는 Object 클래스에서 선언한 메소드만 호출 가능함

      ```java
      Object o = new Rerrari();
      o.goFast(); // 불가능
      ```

      ​

  ​

