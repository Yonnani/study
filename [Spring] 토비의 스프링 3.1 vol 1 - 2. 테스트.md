# 토비의 스프링 3.1

## Vol.1 스프링의 이해와 원리

### 2장 테스트

- 스프링이 개발자에게 제공하는 가장 중요한 가치 - 객체지향과 테스트
- 테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법 중 하나

#### 2.1.1 테스트의 유용성

- 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업

#### 2.1.2 UserDaoTest의 특징

- 테스트 코드

```java
public class UserDaoTest {
    public static void main(String[] args) throws SQLException {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        
        User user = new User();
        user.setId("user");
        user.setName("백기선");
        user.setPassword("married");
        
        dao.add(user);
        
        System.out.println(user.getId() + " 등록 성공");
        
        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());
        
        System.out.println(user2.getId() + " 조회 성공");
    }
}
```

> - 자바에서 쉽게 실행 가능한 main() 메소드 이용
> - 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드 호출함
> - 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어줌
> - 테스트의 결과를 콘솔에 출력함
> - 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지 출력

##### 웹을 통한 DAO 테스트 방법의 문제점

##### 작은 단위의 테스트

- 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 함
- 단위 테스트(unit test) : 작은 단위의 코드에 대해 테스트를 수행한 것
- 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위
- 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 함
- 개발자 테스트/프로그래머 테스트 : 단위 테스트는 주로 개발자가 만든 코드를 스스로 확인하기 위해 사용

##### 자동수행 테스트 코드

- UserDaoTest의 한 특징
  - 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 또한 코드를 통해 자동 실행된다는 점
- 테스트가 사람의 수작업을 거치기 보다는 코드로 만들어져서 자동으로 수행될 수 있어야 함
- 별도의 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 나음
- 자동 수행 테스트의 장점 : 자주 반복 가능, 언제든 코드 수정 후 테스트 가능


##### 지속적인 개선과 점진적인 개발을 위한 테스트

- 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있음

#### 2.1.3 UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
  - 테스트 수행은 코드에 의해 자동으로 진행되지만 테스트 결과 확인은 사람의 책임이므로 완전히 자동 테스트는 아님
- 실행 작업의 번거로움

### 2.2 UserDaoTest 개선

#### 2.2.1 테스트 검증의 자동화

- 모든 테스트의 결과는 성공/실패 둘 중 하나임
- 테스트 실패
  1. 테스트가 진행되는 동안 에러 발생해서 실패 : 테스트 에러
  2. 테스트 작업 중에 에러가 발생하지 않아도 그 결과가 기대한 것과 다르게 나오는 경우 : 테스트 실패
- 전체 기능에 문제가 없는지 점검하는 것은 불가능
- 자동화된 포괄적인 테스트(comprehensive test)를 만든 후에는 개발한 애플리케이션을 수정 후에도 테스트 돌려보면 안심이 되며 테스트를 통해 그 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치 가능함


#### 2.2.2 테스트의 효율적인 수행과 결과 관리

- 자바 테스팅 프레임워크 : JUnit

###### JUnit 테스트로 전환

###### 테스트 메소드 전환

- JUnit 프레임워크가 요구하는 조건
  1. 메소드가 public 으로 선언되어야 함
  2. 메소드에 @Test 애노테이션 붙여야 함
- 메소드명은 테스트의 의도가 무엇인지 알 수 있는 이름이 좋음

###### 검증 코드 전환

- ```java
  if (!user.getName().equals(user2.getName())) { ... }
  ```

  if 문장의 기능을 JUnit이 제공해주는 **assertThat** 이라는 스태틱 메소드를 이용해 다음과 같이 변경 가능

  ```Java
  assertThat(user2.getName(), is(user.getName()));
  ```

- assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 패스 아니면 테스트 실패

###### JUnit 테스트 실행

- AssertionError
  - JUnit은 assertThat()을 이용해서 검증 시, 예상 결과와 다르면 AssertionError 던짐
  - 테스트는 더 이상 진행되지 않고 JUnit은 테스트 실패했음을 알게 됨
  - 테스트 수행 중 일반 예외 발생시에도 테스트 중단되고 테스트 실패함

### 2.3 개발자를 위한 테스팅 프레임워크 JUnit

#### 2.3.1 JUnit 테스트 실행 방법

###### IDE

###### 빌드 툴

#### 2.3.2 테스트 결과의 일관성

###### deleteAll()의 getCount() 추가

###### deleteAll()과 getCount()의 테스트

###### 동일한 결과를 보장하는 테스트

- 단위 테스트는 항상 일관성 있는 결과가 보장되어야 함
- DB의 남은 데이터와 같은 외부 환경에 영향을 받지 말아야하며 테스트 실행 순서가 변경되어도 동일한 결과가 보장되어야 함

#### 2.3.3 포괄적인 테스트

###### getCount() 테스트

- 테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋음
- JUnit은 하나의 클래스 안에 여러개의 테스트 메소드 들어가는 것 허용함
  - @Test가 붙어있고 public 접근자가 있으며 리턴 값이 void 형이고 파라미터가 없다는 조건만 지키면 됨
- JUnit은 테스트 메소드 실행 순서 보장해주지 않음
- 모든 테스트는 실행 순서에 관계없이 독립적으로 항상 동일한 결과를 내야함


###### addAndGet() 테스트 보완

###### get() 예외조건에 대한 테스트

- 예외 발생 여부는 메소드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없는 문제 존재

  - assertThat() 메소드로 검증 불가능
  - 이 문제를 해결하기 위해 JUnit은 예외조건 테스트를 위한 방법 제공

  ```java
  @Test(expected=EmptyResultDataAccessException.class)
  public void getUserFailure() throws SQLException {
      ...
  }
  ```

  - @Test 애노테이션의 expected 엘리먼트에 예외 클래스 넣어주면 됨

###### 테스트를 성공시키기 위한 코드의 수정

