# Head First Java

## 7. 상속과 다형성

- 오버라이딩 : 하위클래스에서 메소드의 역할을 변경하거나 확장할 필요가 있을 때 상속받은 메소드를 새로 정의하는 것

#### 상속의 이해

- 한 클래스가 다른 클래스를 상속하는 것을 **하위클래스가 상위클래스로부터 상속받는다**고 말함
- **하위클래스가 상위클래스를 확장(extend)한다**고 함
- 인스턴스 변수와 메소드 : 클래스의 멤버

#### 상속 예제

1. 공통적인 속성과 행동이 들어있는 객체 찾기
2. 공통적인 상태와 행동을 나타내는 클래스를 설계
   1. 객체들은 모두 동물이므로 Animal이라는 공통적인 상위 클래스 생성
   2. 그 객체 안에 모든 동물이 필요로 하는 메소드와 인스턴스 변수 입력
      1. 인스턴스 변수 : picture, food, hunger, doundaries, location
      2. 메소드 : makeNoise(), eat(), sleep(), roam()
3. 특정 하위클래스 유형에만 적용되는 행동(메소드 구현)이 필요한지 결정
   1. Animal의 각 하위클래스에서 eat(), makeNoise()를 오버라이드해야 함
4. 공통적인 행동이 필요한 하위클래스를 두 개 이상 찾아보기
   1. Wolf와 Dog에 공통적인 행동이 있고 Lion, Tiger, Cat에도 공통적인 행동이 있음
5. 클래스 계층 구조 완성
   1. 생물 분류 체계에서의 "과"를 활용하여 Feline(고양이과) 클래스와 Canine(개과) 클래스를 만들어서 조직화
   2. 개과 동물은 무리 지어서 움직이는 성향이 있으므로 Canine 클래스에서 공통적인 roam() 메소드 생성 가능
   3. 고양이과 동물은 같은 종류에 속하는 다른 동물을 피하려는 습성 있으므로 공통적인 roam() 메소드 생성 가능
   4. Hippo 클래스에서는 Animal에 있는 일반적인 roam() 메소드 활용 예정

- 객체 레퍼런스에 있는 메소드 호출하면 그 객체 형식의 메소드 중 가장 구체적인 버전이 호출됨 == 상속 트리에서 가장 아래쪽에 있는 것이 호출됨

- A는 B다 : A(하위클래스)가 B(상위클래스)를 상속 가능

- A에는 B가 있다 : A에는 B 인스턴스 변수가 들어가면 됨

- 어떤 클래스가 다른 클래스(상위클래스)를 더 구체화한 형식이라면 상속을 활용함

- 단지 어떤 코드를 재사용할 수 있다는 이유만으로 상속을 사용하면 안됨

- 핵심 정리

  - 하위클래스는 상위클래스를 확장함
  - 하위클래스는 상위클래스에 있는 모든 public으로 지정한 인스턴스 변수와 메소드를 상속하지만 private으로 지정된 인스턴스 변수와 메소드는 상속하지 않음
  - 메소드는 오버라이드할 수 있지만 인스턴스 변수는 오버라이드할 수 없음(하위클래스에서 재정의할 수는 있음)
  - 'A는 B다' 테스트로 상속 계층이 올바른지 확인할 것
  - 'A는 B다' 관계는 한 방향으로만 작동함
  - 하위클래스에서 메소드를 오버라이드하면, 그리고 하위클래스의 인스턴스에 대해 그 메소드를 호출하면 오버라이드된 버전의 메소드가 호출됨
  - B 클래스가 A 클래스를 확장하고 C는 B를 확장한다면 클래스 B는 클래스 A이고 클래스 C는 클래스 B이고 클래스 C는 클래스 A임

- 상속의 이점

  - 코드 중복 방지
  - 일련의 클래스를 위한 공통적인 규약(protocol)을 정의함
    - 특정 상위클래스 밑에 모여있는 모든 클래스에, 상위클래스에 들어있는 (상속 가능한) 모든 메소드가 들어가게 할 수 있음

- 다형성을 활용하면 레퍼런스와 객체가 다른 유형이어도 됨

  ```java
  Animal myDog = new Dog();
  ```

  - 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정 가능

  ```java
  Animal[] animals = new Animal[5];
  // Animal 배열에는 Animal의 하위클래스에 속하는 모든 객체를 집어넣을 수 있음
  animals[0] = new Dog();
  animals[1] = new Cat();
  animals[2] = new Wolf();
  animals[3] = new Hippo();
  animals[4] = new Lion();

  for (int i = 0; i < animals.length; i++) {
      // 배열의 모든 원소에 대해 순환문을 돌리면서 
      // Animal 클래스에 들어있는 메소드 중 하나를 실행시키면 
      // 각 객체마다 올바른 메소드를 실행함
      animals[i].eat();
      animals[i].roam();
  }
  ```

  ```java
  class Vet { // 수의사
      
      public void giveShot(Animal a) {
          // a 매개변수로 가리키고 있는 Animal 객체에 대해
          // 주사를 놓음
          // 힙에 실제로 들어있는 Animal 클래스의 하위클래스 유형에 따라
          // 적당한 makeNoise() 메소드가 실행됨
          a.makeNoise();
      }
  }
  ```

  ```
  class PetOwner {
      public void start() {
          Vet v = new Vet();
          Dog d = new Dog();
          Hippo h = new Hippo();
          v.giveShot(d); // Dog의 makeNoise() 실행됨
          v.giveShot(h); // Hippo의 makeNoise() 실행됨
      }
  }
  ```

- 클래스를 확장할 수 없는 경우

  1. public이 아닌 클래스의 하위클래스는 그 클래스와 같은 패키지 안에서만 생성가능하고 다른 패키지에 속한 클래스는 확장할 수 없음
  2. 클래스를 final로 지정하면 그 클래스는 상속 계층에서 맨 아래에 있는 클래스가 되므로 절대 확장할 수 없음
  3. 클래스 생성자가 모두 private으로 지정된 경우

- final 클래스 이유? 하위클래스를 못 만들게 하는 것의 장점?

  - 보안을 유지하기 위해 메소드가 항상 자신이 만든 상태로 실행되도록 하고 싶은 경우 즉, 오버라이드할 수 없도록 만들고 싶은 경우
  - 예 : String 클래스도 final 클래스임

- 오버라이드 규칙

  1. 인자는 똑같아야 하고, 리턴 유형은 호환 가능해야 함
  2. 메소드를 더 접근하기 어렵게 만들면 안됨
     - 예를 들어, public 메소드를 오버라이드해서 private 메소드를 만들수 없음

- 메소드 오버로딩(overloading)

  - 이름이 같고 인자 목록이 다른 메소드를 여러개 만드는 것
  - 오버로드된 메소드는 다형성과 관계 없음
  - 리턴 유형이 달라도 됨
  - 리턴 유형만 바꿀 수는 없음
    - 리턴 유형과 무관하게 인자 목록을 반드시 변경해야 함
  - 접근 단계를 마음대로 바꿀 수 있음