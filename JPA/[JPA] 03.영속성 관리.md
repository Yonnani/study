# 자바 ORM 표준 JPA 프로그래밍

## 3. 영속성 관리

### 3.1 엔티티 매니저 팩토리와 엔티티 매니저

- 데이터베이스를 하나만 사용하는 애플리케이션은 보통 EntityManagerFactory를 하나만 생성함
  - 엔티티 매니저를 만드는 공장
  - 공장을 만드는 비용이 큼 -> 하나만 만들어서 앱 전체에서 공유
- 그 후 필요할 때마다 엔티티 매니저 팩토리에서 엔티티 매니저 생성
- 엔티티 매니저 팩토리는 스레드 간에 공유해도 안전, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제 발생하므로 스레드 간에 절대 공유하면 안 됨

### 3.2 영속성 컨텍스트란?

- 영속성 컨텍스트(persistence context) : 엔티티를 영구 저장하는 환경

### 3.3 엔티티 생명주기

- 엔티티의 4가지 상태
  - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 영속(managed) : 영속성 컨텍스트에 저장된 상태
  - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 삭제(removed) : 삭제된 상태
- 비영속
  - 엔티티 객체 생성, 순수한 객체 상태임
  - 아직 저장하기 전
- 영속
  - 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장
  - 영속성 컨텍스트가 관리하는 엔티티를 영속 상태
- 준영속
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 됨
- 삭제
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

### 3.4  영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값
  - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분함
  - 영속 상태는 식별자 값이 반드시 있어야 함 (없으면 예외 발생)
- 영속성 컨텍스트와 데이터베이스 저장
  - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영 : 플러시(flush)
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있음
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

#### 3.4.1 엔티티 조회

- 영속성 컨텍스트는 내부에 캐시를 가지고 있음 : 1차 캐시
  - 영속 상태의 엔티티는 모두 이곳에 저장
- 1차 캐시의 키는 식별자 값
- 식별자 값은 DB의 기본 키와 맵핑되어 있음
- `em.find()`를 호출하면 1차 캐시에서 엔티티를 찾고, 없으면 DB에서 조회함

##### 1차 캐시에서 조회

- `em.find()`를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾음
- 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회함

##### 데이터베이스에서 조회

- 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성함
- 1차 캐시에 저장한 후 영속 상태의 엔티티를 반환함

##### 영속 엔티티의 동일성 보장

- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장함

> **동일성과 동등성**
>
> - 동일성(identity): 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.
> - 동등성(equality): 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. 자바에서 동등성 비교는 equals() 메소드를 구현해야 한다.

> JPA는 1차 캐시를 통해 반복 가능한 읽기(Repeatable read) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점이 있음

#### 3.4.2 엔티티 등록

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 모아둠
- 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)이라 함

#### 3.4.3 엔티티 수정

##### SQL 수정 쿼리의 문제점

- 수정 쿼리가 많아지고, 비지니스 로직을 분석하기 위해 SQL을 확인해야 함(비지니스 로직이 SQL에 의존하게 됨)

##### 변경 감지

- 변경 감지(dirty checking) : 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
- 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용됨
- `DynamicUpdate` 어노테이션을 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성함
- `@DaynamicInsert`는 데이터가 존재하는(null이 아닌) 필드만으로 INSERT SQL을 동적으로 생성함

#### 3.4.4 엔티티 삭제

- 엔티티를 삭제하려면 삭제 대상 엔티티를 조회해야 함
- `em.remove()`에 삭제 대상 엔티티를 넘겨주면 삭제함
- `em.remove(memberA)`는 호출하는 순간 memberA는 영속성 컨텍스트에서 제거됨

### 3.5 플러시

- 플러시(`flush()`)는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영함
- 영속성 컨텍스트를 플러시하는 방법
  - 직접 호출
  - 트랜잭션 커밋 시 플러시 자동 호출
  - JPQL 쿼리 실행 시 플러시 자동 호출

#### 3.5.1 플러시 모드 옵션

- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이 플러시임

### 3.6 준영속

- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된(detached) 것 : 준영속 상태
- 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음

#### 3.6.1 엔티티를 준영속 상태로 전환: detach()

#### 3.6.2 영속성 컨텍스트 초기화: clear()

- `em.clear()`는 영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듦

#### 3.6.3 영속성 컨텍스트 종료: close()

- 영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 됨

#### 3.6.4 준영속 상태의 특징

- 거의 비영속에 가까움
- 식별자 값을 가지고 있음
- 지연 로딩을 할 수 없음

#### 3.6.5 병합: merge()

- 준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 됨
- 새로운 영속 상태의 엔티티를 반환함
- 병합(merge)은 비영속 엔티티도 영속 상태로 만들 수 있음
- 병합은 준영속, 비영속에 관계없이 식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고 조회할 수 없으면 새로 생성해서 병합함

### 3.7 정리