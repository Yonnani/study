# 토비의 스프링 3.1

## Vol.1 스프링의 이해와 원리

### 1장 오브젝트와 의존관계

- 스프링이 가장 관심을 많이 두는 대상은 **오브젝트**임

#### 1.1 초난감 DAO

- DAO(Data Access Object) : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

##### 1.1.1 User

- 자바빈(JavaBean) 
  - 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말함
  - 이제는 다음 두 가지 관례를 따라 만들어진 오브젝트를 가리킴
    - 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
    - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

##### 1.1.2 UserDao

- JDBC를 이용하는 작업의 일반적인 순서
  - DB 연결을 위한 Connection을 가져온다.
  - SQL을 담은 Statement(또는 PreparedStatement)를 만든다.
  - 만들어진 Statement를 실행한다.
  - 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트(ex. User)에 옮겨준다.
  - 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.
  - JDBC API가 만들어내는 예외(Exception)를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

##### 1.1.3 main()을 이용한 DAO 테스트 코드

#### 1.2 DAO의 분리

##### 1.2.1 관심사의 분리

- 프로그래밍의 기초 개념 중에 **관심사의 분리**(Separation of Concerns)가 있음
  - 이를 객체지향에 적용해보면, 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것
  - 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것

##### 1.2.2 커넥션 만들기의 추출

###### UserDao의 관심사항

- DB 연결과 관련된 관심
- 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
- 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아서 공유 리소스를 시스템에 돌려주는 것

###### 중복 코드의 메소드 추출

- 중복된 DB 연결 코드를 `getConnection()`이라는 이름의 독립적인 메소드로 만듦

###### 변경사항에 대한 검증: 리팩토링과 테스트

- 리팩토링(refactoring) : 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술 (리팩토링 참고서 : "리팩토링"(마틴 파울러, 켄트 벡 공저))
- 리팩토링에서 메소드 추출 기법(extract method)
  - 앞의 `getConnection()`과 같이 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것

##### 1.2.3 DB 커넥션 만들기의 독립

- 고객에게 UserDao의 소스를 직접 공개하지 않고 컴파일된 클래스 바이너리 파일만 제공하고 싶은 경우, 고객 스스로 원하는 DB 커넥션 생성 방식을 적용하게 하려면?

###### 상속을 통한 확장

- 기존의 UserDao 코드를 한 단계 더 분리하면 됨
  - 만들어진 UserDao에서 메소드 구현 코드를 제거, `getConnection()`을 추상 메소드로 만듦
  - 이 추상 클래스인 UserDao를 고객에게 판매
  - 고객은 UserDao 클래스를 상속해서 서브클래스를 만듦
  - 서브클래스에서는 `getConnection()` 메소드를 원하는 방식대로 구현할 수 있음
- 템플릿 메소드 패턴(template method pattern) : 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법
- 팩토리 메소드 패턴(factory method pattern) : 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

> 디자인 패턴
>
> - 디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
> - 모든 패턴에는 간결한 이름이 있어서 잘 알려진 패턴을 적용하고자 할 때 패턴 이름을 언급하는 것만으로도 설계의 의도와 해결책을 함께 설명할 수 있다는 장점이 있음
> - 디자인 패턴은 주로 객체지향 설계에 관한 것, 대부분 객체 지향적 설계 원칙을 이용해 문제를 해결함
> - 패턴의 두 가지 구조
>   - 클래스 상속
>   - 오브젝트 합성

> 템플릿 메소드 패턴
>
> - 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
> - 변하지 않는 기능은 슈퍼클래스에, 자주 변경되며 확장할 기능은 서브 클래스에서 만듦
> - 훅(hook) 메소드 : 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드
> - 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장함
>
> ```java
> public abstract class Super {
>     // 기본 알고리즘 골격을 담은 메소드를 템플릿 메소드라고 부름
>     // 템플릿 메소드는 서브클래스에서 오버라이드하거나 구현할 메소드를 사용함
>     public void templateMethod() {
>         // 기본 알고리즘 코드
>         hookMethod();
>         abstractMethod();
>         ...
>     }
>     
>     protected void hookMthod() {} // 선택적으로 오버라이드 가능한 훅 메소드
>     public abstract void abstractMethod(); // 서브클래스에서 반드시 구현해야 하는 추상 메소드
> }
> 
> // 슈퍼클래스의 메소드를 오버라이드하거나 구현해서 기능을 확장함
> // 다양한 확장 클래스를 만들 수 있음
> public class Sub1 extends Super {
>     protected void hookMethod() {...}
>     public void abstractmethod() {...}
> }
> ```

