# 토비의 스프링 3.1

## Vol.1 스프링의 이해와 원리

### 2장 테스트

- 스프링이 개발자에게 제공하는 가장 중요한 가치 - 객체지향과 테스트
- 테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법 중 하나

#### 2.1.1 테스트의 유용성

- 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업

#### 2.1.2 UserDaoTest의 특징

- 테스트 코드

```java
public class UserDaoTest {
    public static void main(String[] args) throws SQLException {
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        
        User user = new User();
        user.setId("user");
        user.setName("백기선");
        user.setPassword("married");
        
        dao.add(user);
        
        System.out.println(user.getId() + " 등록 성공");
        
        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());
        
        System.out.println(user2.getId() + " 조회 성공");
    }
}
```

> - 자바에서 쉽게 실행 가능한 main() 메소드 이용
> - 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드 호출함
> - 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어줌
> - 테스트의 결과를 콘솔에 출력함
> - 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지 출력

##### 웹을 통한 DAO 테스트 방법의 문제점

##### 작은 단위의 테스트

- 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 함
- 단위 테스트(unit test) : 작은 단위의 코드에 대해 테스트를 수행한 것
- 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위
- 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 함
- 개발자 테스트/프로그래머 테스트 : 단위 테스트는 주로 개발자가 만든 코드를 스스로 확인하기 위해 사용

##### 자동수행 테스트 코드

- UserDaoTest의 한 특징
  - 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 또한 코드를 통해 자동 실행된다는 점
- 테스트가 사람의 수작업을 거치기 보다는 코드로 만들어져서 자동으로 수행될 수 있어야 함
- 별도의 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 나음
- 자동 수행 테스트의 장점 : 자주 반복 가능, 언제든 코드 수정 후 테스트 가능


##### 지속적인 개선과 점진적인 개발을 위한 테스트

- 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있음

#### 2.1.3 UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
  - 테스트 수행은 코드에 의해 자동으로 진행되지만 테스트 결과 확인은 사람의 책임이므로 완전히 자동 테스트는 아님
- 실행 작업의 번거로움

### 2.2 UserDaoTest 개선

#### 2.2.1 테스트 검증의 자동화

- 모든 테스트의 결과는 성공/실패 둘 중 하나임
- 테스트 실패
  1. 테스트가 진행되는 동안 에러 발생해서 실패 : 테스트 에러
  2. 테스트 작업 중에 에러가 발생하지 않아도 그 결과가 기대한 것과 다르게 나오는 경우 : 테스트 실패
- 전체 기능에 문제가 없는지 점검하는 것은 불가능
- 자동화된 포괄적인 테스트(comprehensive test)를 만든 후에는 개발한 애플리케이션을 수정 후에도 테스트 돌려보면 안심이 되며 테스트를 통해 그 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치 가능함


#### 2.2.2 테스트의 효율적인 수행과 결과 관리

- 자바 테스팅 프레임워크 : JUnit

###### JUnit 테스트로 전환

###### 테스트 메소드 전환

- JUnit 프레임워크가 요구하는 조건
  1. 메소드가 public 으로 선언되어야 함
  2. 메소드에 @Test 애노테이션 붙여야 함
- 메소드명은 테스트의 의도가 무엇인지 알 수 있는 이름이 좋음

###### 검증 코드 전환

- ```java
  if (!user.getName().equals(user2.getName())) { ... }
  ```

  if 문장의 기능을 JUnit이 제공해주는 **assertThat** 이라는 스태틱 메소드를 이용해 다음과 같이 변경 가능

  ```Java
  assertThat(user2.getName(), is(user.getName()));
  ```

- assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 패스 아니면 테스트 실패

###### JUnit 테스트 실행

- AssertionError
  - JUnit은 assertThat()을 이용해서 검증 시, 예상 결과와 다르면 AssertionError 던짐
  - 테스트는 더 이상 진행되지 않고 JUnit은 테스트 실패했음을 알게 됨
  - 테스트 수행 중 일반 예외 발생시에도 테스트 중단되고 테스트 실패함

### 2.3 개발자를 위한 테스팅 프레임워크 JUnit

#### 2.3.1 JUnit 테스트 실행 방법

###### IDE

###### 빌드 툴

#### 2.3.2 테스트 결과의 일관성

###### deleteAll()의 getCount() 추가

###### deleteAll()과 getCount()의 테스트

###### 동일한 결과를 보장하는 테스트

- 단위 테스트는 항상 일관성 있는 결과가 보장되어야 함
- DB의 남은 데이터와 같은 외부 환경에 영향을 받지 말아야하며 테스트 실행 순서가 변경되어도 동일한 결과가 보장되어야 함

#### 2.3.3 포괄적인 테스트

###### getCount() 테스트

- 테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋음
- JUnit은 하나의 클래스 안에 여러개의 테스트 메소드 들어가는 것 허용함
  - @Test가 붙어있고 public 접근자가 있으며 리턴 값이 void 형이고 파라미터가 없다는 조건만 지키면 됨
- JUnit은 테스트 메소드 실행 순서 보장해주지 않음
- 모든 테스트는 실행 순서에 관계없이 독립적으로 항상 동일한 결과를 내야함


###### addAndGet() 테스트 보완

###### get() 예외조건에 대한 테스트

- 예외 발생 여부는 메소드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없는 문제 존재

  - assertThat() 메소드로 검증 불가능
  - 이 문제를 해결하기 위해 JUnit은 예외조건 테스트를 위한 방법 제공

  ```java
  @Test(expected=EmptyResultDataAccessException.class)
  public void getUserFailure() throws SQLException {
      ...
  }
  ```

  - @Test 애노테이션의 expected 엘리먼트에 예외 클래스 넣어주면 됨

###### 테스트를 성공시키기 위한 코드의 수정
###### 포괄적인 테스트
- 개발자가 테스트를 만들 때 자주 하는 실수 : 성공하는 테스트만 골라서 만드는 것
- 스프링 창시자 로드 존슨 왈, "항상 네거티브 테스트를 먼저 만들라"고 조언 함
- 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋음

#### 2.3.4 테스트가 이끄는 개발

###### 기능설계를 위한 테스트

|      | 단계               | 내용                                      | 코드                                                     |
| :--: | ------------------ | ----------------------------------------- | -------------------------------------------------------- |
| 조건 | 어떤 조건을 가지고 | 가져올 사용자 정보가 존재하지 않는 경우에 | dao.deleteAll();<br />assertThat(dao.getCount(), is(0)); |
| 행위 | 무엇을 할 때       | 존재하지 않는 id로 get()을 실행하면       | get("unknown_id");                                       |
| 결과 | 어떤 결과가 나온다 | 특별한 예외가 던져진다                    | @Test(expected=EmptyResultDataAccessException.class)     |

- 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수 있음
- 테스트가 성공한다면, 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것

###### 테스트 주도 개발

- 테스트 주도 개발(TDD, Test Driven Development) 혹은 테스트 우선 개발(Test First Development) : 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
- "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 것이 TDD의 기본 원칙
- TDD에서는 테스트 작성하고 이를 성공시키는 코드를 만드는 작업 주기를 가능한 한 짧게 가져가도록 권장함
- TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점임
  - 빨리 발견된 오류는 쉽게 대응이 가능함
- 테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 함
- 테스트는 애플리케이션 코드보다 상대적으로 작성하기 쉬우며 각 테스트가 독립적이기 때문에, 코드의 양에 비해 작성 시간은 짧음
  - 테스트를 통해 오류를 빨리 잡아낼 수 있어서 전체 개발 속도는 빨라짐

#### 2.3.5 테스트 코드 개선

- 테스트 코드도 리팩토링해도 됨

###### @Before

- JUnit이 제공하는 애노테이션이며 @Test 메소드가 실행되기 전에 먼저 실행되어야 하는 메소드를 정의함
- JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식
  1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾음
  2. 테스트 클래스의 오브젝트를 하나 만듦
  3. @Before가 붙은 메소드가 있으면 실행함
  4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둠
  5. @After가 붙은 메소드가 있으면 실행함
  6. 나머지 테스트 메소드에 대해 2~5번 반복함
  7. 모든 테스트의 결과를 종합해서 돌려줌
- @Before나 @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문에 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 함
- 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만듦
  - 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위함
- 테스트 메소드의 일부에서만 공통적으로 사용되는 코드가 있다면
  - @Before를 사용하기보다는, 일반적인 메소드 추출 방법을 써서 메소드를 분리하고 테스트 메소드에서 직접 호출해 사용하도록 만드는 편이 나음
  - 아니면 아예 공통적인 특징을 지닌 테스트 메소드를 모아서 별도의 테스트 클래스로 만드는 방법도 있음

###### 픽스처

